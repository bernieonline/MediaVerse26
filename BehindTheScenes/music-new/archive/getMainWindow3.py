# based on version 1.0 and amended





# This file has been created to make use of the .py file generated by the following command run from the command line
# pyuic5 -o newfile.py MainWindow.ui
#pyuic5 -o MediaManager.py MediaManager.ui

#the idea is that as you make changes to the UI and rerun pyuic5 the contruction of the windows
# is separate from the UI code
# getMainWindow inherits the MainWindow properties and in this file we can place our code for listeners, action etc


# MainWindow.ui is created by designer and is an xml file
# the pyuic command generates a .py equivalent file but you must not change any aspect of this file as when
# you change the gui it rewrites the file and you lose the changes
# The correct approach is to create a file like this one that subclasses the Ui_MainWindow,
# which is the class created in
# MainWindow.py, you must take care to note the class of object that the gui file is based on.
# MainWindow is based on QTWidgets.QMainWindow but it could easily be based on just QTWidgets as you will see from
# the database example. The main window has the main menu and will have lots of signals and slots associated with it

# In this example we use the database screen to show after clicking a button
# To do this we need to import and other files and classes that the button click references
# getMasterdb is a file created to access getDbWidow class, this being the class that manages the gui created by
# py designer

# pyuic5 -o CreateMasterdatabase.py CreateMasterDatabase.ui
# pyuic5 -o MainWindow.py MainWindow.ui
# pyuic5 -o FFMpeg.py ffmpeg.ui
# pyuic5 -o moveNewFiles.py moveNewFiles.ui
# pyuic5 -o GroupAnalysis.py GroupAnalysis.ui


# Note ------this pyuic5 is not really necessary. Its good practice on larger projects to do this as it keeps the ui code separate from the logic code
# for smaller projects its not necessary, as shown in Music.py you can manually create the .py file subclassling the window and then just add the logic
# its quicker as you dont need to keep running pyuic5 each time you modify the ui




import mysql.connector
from MediaManager import Ui_MainWindow
from PyQt5 import QtWidgets
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QMessageBox
import time
import os
from PyQt5.QtCore import QTimer


class DatabaseConnectionThread(QThread):
    connection_success = pyqtSignal()
    connection_failed = pyqtSignal(str)

    def __init__(self, config):
        super().__init__()
        self.config = config

    def run(self):
        try:
            connection = mysql.connector.connect(**self.config)
            if connection.is_connected():
                self.connection_success.emit()
            else:
                self.connection_failed.emit("Connection failed without exception.")
        except mysql.connector.Error as err:
            self.connection_failed.emit(f"Connection Failed: {err}")
        except Exception as e:
            self.connection_failed.emit(f"Unexpected error: {e}")


class getWindow(QtWidgets.QMainWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)  # class super subclasses QtWidgets.QMainWindow on which the form is based

        # in the init phase, preceds all new creations with self. to make them accessible from anywhere
        # next 2 actions are critical to setting up the gui that we created

        # Set up the GUI
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

         # Initialize media_types as an empty dictionary to store media types and extensions
        self.media_types = {}

        # Database configuration
        self.config = {
            'host': '192.168.1.100',
            'user': 'root',
            'password': 'Ub24MySql!!!',
            'database': 'mediamanager',
            'ssl_ca': r'X:\Python Projects\BehindTheScenes\pythonProject5\music-new\Certificates\ca-cert.pem',
            'ssl_verify_cert': False,
            'connection_timeout': 30
        }
       
        #self.connect_to_db()  #
        print("Attempting to connect to database...")
        self.connect_to_db()  # Directly attempt the database connection
        
        
        print("GUI initialized")


     # Connect the "Choose Location" action to the method
        self.ui.actionSelect_Location.triggered.connect(self.choose_location)

       # Use QTimer to delay database connection setup after UI shows
        QTimer.singleShot(500, self.setup_db_connection)

    def setup_db_connection(self):
        print("Attempting database connection setup")
        #self.connect_to_db()  # Calls the method to initialize DB connection in the background
    
    
    
    
    def connect_to_db(self):
        try:
            print("Attempting to connect to the database...")
            connection = mysql.connector.connect(**self.config)
            
            if connection.is_connected():
                print("Connection established successfully!")
                self.load_media_types()
            else:
                print("Connection failed.")
        except mysql.connector.Error as err:
            print(f"Connection Failed: {err}")
        except Exception as e:
            print(f"Unexpected error: {e}")
        finally:
            if 'connection' in locals() and connection.is_connected():
                connection.close()


    def on_connection_success(self):
        print("Connection established successfully!")
        self.load_media_types()
    
    def on_connection_failed(self, error_message):
        print(error_message)
        self.show_no_connection_message()

    def show_no_connection_message(self):
        # Display a message box if connection fails
        QMessageBox.critical(self, "Connection Error", "Failed to connect to the database.")

    def load_media_types(self):
        print("loading media types")
        # Query the database for media types and extensions
        try:
            connection = mysql.connector.connect(**self.config)
            cursor = connection.cursor()
            cursor.execute("SELECT Type, Ext FROM meditypes")
            result = cursor.fetchall()
            for type_, ext in result:
                if type_ not in self.media_types:
                    self.media_types[type_] = []
                self.media_types[type_].append(ext.lower())
            cursor.close()
            connection.close()
            print(f"Loaded media types: {self.media_types}")
        except mysql.connector.Error as err:
            print(f"Database error: {err}")
    
    def choose_location(self):
        print("Choosing Location")
        # This method opens the folder selection dialog when the action is triggered
        options = QFileDialog.Options()
        folder_name = QFileDialog.getExistingDirectory(self, "Select Folder", "", options=options)
        
        if folder_name:
            print(f"Selected location: {folder_name}")
            # After the user selects the folder, you can call another function to process files in that location
            self.process_files_in_location(folder_name)
        else:
            print("No location selected.")


    def process_files_in_location(self, folder_path):
        print("here........1")
        # This method is called once a folder is selected; it uses os.walk to search for media files
        print(f"Processing files in: {folder_path}")
        for root, dirs, files in os.walk(folder_path):
            print("here........2")
            print(f"Current folder: {root}, Subfolders: {dirs}, Files: {files}")

            # Check if the folder contains any media files
            folder_contains_media = False
            print("here........3...")
            for file in files:
                print("here........4")
                if self.is_media_file(file):
                    print("here........5")
                    folder_contains_media = True
                    print(f"Media file found in: {root}")
                    break  # Flag the folder if at least one media file is found

            # Process the folder if it contains media files
            if folder_contains_media:
                print("here........6")
                print(f"Current folder: {root}, Subfolders: {dirs}, Files: {files}")

                print(f"Processing media in folder: {root}")
                self.process_media_files(root, files)  # Process files in each folder independently



    def is_media_file(self, file_name):
        print("def is_media_files")
        # Check if the file extension matches any known media types
        ext = os.path.splitext(file_name)[1].lower()
        for media_type, extensions in self.media_types.items():
            if ext in extensions:
                return True
        return False

    def process_media_files(self, folder_path, files):
        print("here........7")
        print("process media files")
        # This method processes media files in a folder
        for file in files:
            print("here........8")
            if self.is_media_file(file):
                print("here........9")
                print(f"Found media file: {os.path.join(folder_path, file)}")
                self.insert_media_file_details(folder_path, file)

    def insert_media_file_details(self, folder_path, file_name):
        print("here........10")
        print("inserting media files details")
        # Collect file details
        file_path = os.path.join(folder_path, file_name)
        file_type = self.get_file_type(file_name)
        file_size = os.stat(file_path).st_size  # Get file size in bytes
        file_creation_time = os.path.getctime(file_path)
        file_creation_date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(file_creation_time))

        # Insert file details into the database
        try:
            print("here........11")
            print("entering new record creation")
            print("entering new record creation")
            connection = mysql.connector.connect(**self.config)
            cursor = connection.cursor()
            cursor.execute("""
                INSERT INTO MediaFileDetail (file_path, file_name, file_type, file_size, file_creation_date, collection, category)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (file_path, file_name, file_type, file_size, file_creation_date, '', ''))  # Empty collection and category for now
            connection.commit()
            print(f"Inserted {file_name} details into the database.")
            cursor.close()
            connection.close()
        except mysql.connector.Error as err:
            print(f"Database error: {err}")

    def get_file_type(self, file_name):
        print("getting file type")
        # Derive file type based on file extension
        ext = os.path.splitext(file_name)[1].lower()
        for media_type, extensions in self.media_types.items():
            if ext in extensions:
                return media_type
        return 'Unknown'

 # when we created the menu button the signal 'actionBuild_Master' was automatically created
        # here we reference it to run the method below that opens the database window when the button is clicked
        # rt click menu option in the main window ui and it will show the name of the action it created

        #self.ui.actionBuild_Master.triggered.connect(self.opendb)   # opendb is the method calling the db GUI

        #self.ui.actionRename_Files.triggered.connect(self.openrename)  # opendb is the method calling the rename ops

        # reminder - right click menu option ui to see the action event that the ui automatically creates
        # and refer to it here pointing to the method that calls the window that I need openff
        ###self.ui.actionFFMpeg_Actions.triggered.connect(self.openff)     # open ffmpeg panel


        # Menu item to distribute new copies
        ###self.ui.actionDistribute_Copies.triggered.connect(self.moveFiles)

        ###self.ui.actionFile_Group_Analysis.triggered.connect(self.groupFiles)


    # this method displays the database GUI

    # @staticmethod
    #def opendb(self):

        # The window is disappearing because it goes out of scope . Since there are no further references to it,
        # the python garbage collector removes it.
        # Usually PyQt objects keep references to their children so this is not a problem. Since you want the widget
        # to open in a separate window, you can't assign it a parent,
        # so you need to store a reference to it somewhere else. The obvious candidate is the MainWindow class.
        # You can make it a member of MainWindow by using self.myWin = getDbWindow() .
        #self.mywin = getDbWindow()
        #self.mywin.show()


    #def openrename(self):
        #self.renWindow = getChangeWindow()
        #self.renWindow.show()


    #def openff(self):
        #self.ffWin = movieFFMPEG()          # create var that references the class I developed
                                            # , its init sets up the view
        #self.ffWin.show()                   # then show it


    #def moveFiles(self):
        #self.mvMovies = getDistWindow()
        #self.mvMovies.show()

    #def groupFiles(self):
        #self.grMovies = getGroupWindow()
        #self.grMovies.show()

if __name__ == "__main__":
    app = QApplication([])  # Create the application instance
    window = getWindow()     # Create an instance of your window
    window.show() 
    print("..................1a")           # Show the window
    # Delay the database connection slightly after window loads
   
    print("..................2a")  
    app.exec_()              # Start the event loop
