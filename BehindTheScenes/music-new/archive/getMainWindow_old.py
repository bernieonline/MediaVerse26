'''
 based on version 1.0 and amended





 This file has been created to make use of the .py file generated by the following command run from the command line
 pyuic5 -o newfile.py MainWindow.ui
pyuic5 -o MediaManager.py MediaManager.ui

the idea is that as you make changes to the UI and rerun pyuic5 the contruction of the windows
 is separate from the UI code
 getMainWindow inherits the MainWindow properties and in this file we can place our code for listeners, action etc


 MainWindow.ui is created by designer and is an xml file
 the pyuic command generates a .py equivalent file but you must not change any aspect of this file as when# you change the gui it rewrites the file and you lose the changes
 The correct approach is to create a file like this one that subclasses the Ui_MainWindow,
 which is the class created in
 MainWindow.py, you must take care to note the class of object that the gui file is based on.
 MainWindow is based on QTWidgets.QMainWindow but it could easily be based on just QTWidgets as you will see from
 the database example. The main window has the main menu and will have lots of signals and slots associated with it

 In this example we use the database screen to show after clicking a button
 To do this we need to import and other files and classes that the button click references
 getMasterdb is a file created to access getDbWidow class, this being the class that manages the gui created by
 py designer

 pyuic5 -o CreateMasterdatabase.py CreateMasterDatabase.ui
 pyuic5 -o MainWindow.py MainWindow.ui
 pyuic5 -o FFMpeg.py ffmpeg.ui
 pyuic5 -o moveNewFiles.py moveNewFiles.ui
 pyuic5 -o GroupAnalysis.py GroupAnalysis.ui
 pyuic5 -o MediaManager.py MediaManager.ui



 Note ------this pyuic5 is not really necessary. Its good practice on larger projects to do this as it keeps the ui code separate from the logic code
 for smaller projects its not necessary, as shown in Music.py you can manually create the .py file subclassling the window and then just add the logic
 its quicker as you dont need to keep running pyuic5 each time you modify the ui

'''







import sys
import logging
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QVBoxLayout
from PyQt5 import QtWidgets
from dbMySql.db_utils import (
    test_mysql_connection,
    summary_coll_list,
    get_distinct_values_with_all,
    get_filtered_data,
    get_unique_locations,
    fetch_collection_summary
)
from MediaManager import Ui_MainWindow
from srcMedia.searchLocation import SearchLocation
from createMasterCollection_old import createMasterCollection
from srcMedia.SearchMasterLocation import SearchMasterLocation
from srcMedia.pie_collection import pie_collection
from srcMedia.compare_collections import Compare_Collections
from srcMedia.lcd_updater import LCDUpdater
from srcMedia.searchLocation import Worker
from srcMedia.SearchMasterLocation import Worker2


class getWindow(QMainWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.showMaximized()

        self.footer = self.ui.Footer
        self.media_progress_bar = self.ui.media_thread_progress
        self.master_progress_bar = self.ui.master_thread_progress

        #control panel display
        self.cpu_lcd = self.ui.cpu_lcd
        self.ram_lcd = self.ui.ram_lcd
        self.lan_lcd = self.ui.lan_lcd
        self.filecount_lcd = self.ui.filecount_lcd

        # Initialize the LCDUpdater
        self.lcd_updater = LCDUpdater(self.cpu_lcd, self.ram_lcd, self.lan_lcd)



        self.search_instance = SearchLocation(parent=self, Footer=self.footer, media_progress_bar=self.media_progress_bar)
        self.search_master = createMasterCollection(
            parent=self, Footer=self.footer, master_progress_bar=self.master_progress_bar)

        self.setup_connections()
        self.populate_comparison_combos()
        self.run_connection_test()

    def setup_connections(self):
        self.ui.actionChoose_Local_Drive.triggered.connect(self.searchCollections)
        self.ui.actionselect_Master_Location.triggered.connect(self.searchMasterCollections)
        self.ui.actionSearching.triggered.connect(self.display_collections)
        self.ui.actionCompare_Sets.triggered.connect(self.compareSets)
        self.ui.actionQuit.triggered.connect(self.program_exit)
        self.ui.actionFile_Extension_List.triggered.connect(self.viewExtensions)
        self.ui.actionCollections_2.triggered.connect(self.viewCollections)

        #self.ui.dev_combo.currentIndexChanged.connect(self.update_pie_chart)
        #self.ui.cat_combo.currentIndexChanged.connect(self.update_pie_chart)

        self.ui.masterRadio.toggled.connect(self.populate_combo_boxes)
        self.ui.collRadio.toggled.connect(self.populate_combo_boxes)

        self.ui.chartButton.clicked.connect(self.update_pie_chart)
        self.ui.compare_btn.clicked.connect(self.run_comparison)

        self.ui.collRadio.setChecked(True)

    def run_connection_test(self):
        try:
            state = test_mysql_connection()
            message = "MySql is Connected........." if state else "No Mysql Connection........."
            self.footer.append(message)
        except Exception as e:
            logging.error(f"Error testing MySQL connection: {e}")
            self.footer.append("Error testing MySQL connection.")

    def populate_combo_boxes(self):
        logging.info("Running populate_combo_boxes")
        selected_radio = "master" if self.ui.masterRadio.isChecked() else "collection"
        devices = get_distinct_values_with_all('device', selected_radio)
        categories = get_distinct_values_with_all('category', selected_radio)

        self.ui.dev_combo.clear()
        self.ui.dev_combo.addItems(devices)

        self.ui.cat_combo.clear()
        self.ui.cat_combo.addItems(categories)

    def populate_comparison_combos(self):
        collections = get_unique_locations()
        self.ui.combo_compareA.clear()
        self.ui.combo_compareB.clear()
        self.ui.combo_compareA.addItems(collections)
        self.ui.combo_compareB.addItems(collections)

        items = ['Items in B but Not in A', 'Items in A but Not in B']
        self.ui.combo_compareType.addItems(items)

        tables = ['mediafiledetail', 'masterfiledetail']
        self.ui.comboBox_table1.addItems(tables)
        self.ui.comboBox_table2.addItems(tables)

    def run_comparison(self):
        selected_compareA = self.ui.combo_compareA.currentText()
        selected_compareB = self.ui.combo_compareB.currentText()
        selected_compareType = self.ui.combo_compareType.currentText()

        comparison = Compare_Collections(
            selected_compareA, selected_compareB, selected_compareType,
            self.ui.tableView, self.ui.comboBox_table1, self.ui.comboBox_table2
        )
        comparison.run()

    def display_collections(self):
        logging.info("Running display_Collections")
        self.footer.clear()
        results = fetch_collection_summary()
        results_text = self.format_results(results)
        self.footer.setPlainText(results_text)

    def format_results(self, results):
        return "\n".join("\t".join(map(str, row)) for row in results)

    def searchCollections(self):
        logging.info("Running searchCollections")
        self.display_collections()
        self.search_instance.run()

        # Connect the worker's signal to update the file count LCD
        self.search_instance.worker.record_counter_signal.connect(self.update_filecount_lcd)

    def update_filecount_lcd(self, count):
        print(f"Updating file count LCD with count: {count}")
        self.filecount_lcd.display(count)


    def searchMasterCollections(self):
        logging.info("Running searchMasterCollections")
        self.display_collections()
        self.search_master.run()

         # Ensure search_master_instance is initialized
        if self.search_master.search_master_instance and hasattr(self.search_master.search_master_instance, 'worker2'):
            logging.info("Worker2 is or search_master_instance is set.")
            self.search_master.search_master_instance.worker2.record_counter_signal.connect(self.update_filecount_lcd)
        else:
            logging.error("Worker2 is not instantiated or search_master_instance is not set.")

        # Connect the worker's signal to update the file count LCD
        #self.search_master.search_master_instance.worker2.record_counter_signal.connect(self.update_filecount_lcd)
        #worker2.record_counter_signal.connect(self.update_filecount_lcd)

    def program_exit(self):
        sys.exit()

    def viewExtensions(self):
        pass

    def viewCollections(self):
        logging.info("Running viewCollections")
        data = summary_coll_list()
        self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())
        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)
        self.ui.stackedWidget.setCurrentWidget(self.ui.page)

    def update_pie_chart(self):
        logging.info("Running update_pie_chart, gets get_filtered_data, runs refresh_pie_chart")
        selected_device = self.ui.dev_combo.currentText()
        selected_category = self.ui.cat_combo.currentText()
        selected_radio = "master" if self.ui.masterRadio.isChecked() else "collection"
        data = get_filtered_data(selected_device, selected_category, selected_radio)
        self.refresh_pie_chart(data)

    def refresh_pie_chart(self, data):
        logging.info("Running refresh_pie_chart, runs pie_collection")
        if not self.ui.canvas_frame.layout():
            self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())

        if hasattr(self, 'pie_chart_widget'):
            self.ui.canvas_frame.layout().removeWidget(self.pie_chart_widget)
            self.pie_chart_widget.deleteLater()

        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)

    def compareSets(self):
        self.ui.stackedWidget.setCurrentIndex(1)

