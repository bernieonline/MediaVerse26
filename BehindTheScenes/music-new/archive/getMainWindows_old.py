# based on version 1.0 and amended





# This file has been created to make use of the .py file generated by the following command run from the command line
# pyuic5 -o newfile.py MainWindow.ui
#pyuic5 -o MediaManager.py MediaManager.ui

#the idea is that as you make changes to the UI and rerun pyuic5 the contruction of the windows
# is separate from the UI code
# getMainWindow inherits the MainWindow properties and in this file we can place our code for listeners, action etc


# MainWindow.ui is created by designer and is an xml file
# the pyuic command generates a .py equivalent file but you must not change any aspect of this file as when
# you change the gui it rewrites the file and you lose the changes
# The correct approach is to create a file like this one that subclasses the Ui_MainWindow,
# which is the class created in
# MainWindow.py, you must take care to note the class of object that the gui file is based on.
# MainWindow is based on QTWidgets.QMainWindow but it could easily be based on just QTWidgets as you will see from
# the database example. The main window has the main menu and will have lots of signals and slots associated with it

# In this example we use the database screen to show after clicking a button
# To do this we need to import and other files and classes that the button click references
# getMasterdb is a file created to access getDbWidow class, this being the class that manages the gui created by
# py designer

# pyuic5 -o CreateMasterdatabase.py CreateMasterDatabase.ui
# pyuic5 -o MainWindow.py MainWindow.ui
# pyuic5 -o FFMpeg.py ffmpeg.ui
# pyuic5 -o moveNewFiles.py moveNewFiles.ui
# pyuic5 -o GroupAnalysis.py GroupAnalysis.ui
# pyuic5 -o MediaManager.py MediaManager.ui



# Note ------this pyuic5 is not really necessary. Its good practice on larger projects to do this as it keeps the ui code separate from the logic code
# for smaller projects its not necessary, as shown in Music.py you can manually create the .py file subclassling the window and then just add the logic
# its quicker as you dont need to keep running pyuic5 each time you modify the ui



# from RenameSystem import Ui_MovieFileRename
####from GroupAction import getGroupWindow
####from distributeMovies import getDistWindow

from dbMySql.db_utils import test_mysql_connection  #uses mysql functions page
from dbMySql.db_utils import summary_coll_list #initialises first chart display before filering
from dbMySql.db_utils import get_distinct_values_with_all
from dbMySql.db_utils import get_filtered_data
from dbMySql.db_utils import get_unique_locations
from dbMySql.db_utils import fetch_collection_summary 
import mysql.connector
from MediaManager import Ui_MainWindow
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QTextEdit, QVBoxLayout, QHBoxLayout, QFrame, QProgressBar
from PyQt5 import QtWidgets
from srcMedia.searchLocation import SearchLocation
from createMasterCollection_old import createMasterCollection
import sys
from srcMedia.pie_collection import pie_collection
from srcMedia.compare_collections import Compare_Collections

#the logic here is to run commands from the menu
#the listeners and triggers will be in here
# the actions will run a method such as doDb() which will caa
# a program file such as searchLocation which will do the work



class getWindow(QMainWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Set up the GUI
        self.ui = Ui_MainWindow()
        
        #setupUi is part of the gui manager. its a function
        self.ui.setupUi(self)
        self.showMaximized()

        

        # Set stretch factors for equal space distribution
        #self.ui.horizontalLayout.setStretch(0, 1)  # For self.pi_collections
        #self.ui.horizontalLayout.setStretch(1, 1)  # For self.frame_2

        #used to send message to footer
        self.footer=self.ui.Footer

        print("Testing Connection........")
        #test connection to database and send message to footer
        self.run_connection_test()

        #thread progress bars
        self.media_progress_bar = self.ui.media_thread_progress
        self.master_progress_bar = self.ui.master_thread_progress   

        # Initialize SearchLocation instance for media collections
        #self.search_instance = SearchLocation(parent=self, Footer=self.footer)
        self.search_instance = SearchLocation(parent=self, Footer=self.footer, media_progress_bar= self.media_progress_bar)

         # Initialize  instance for master collections
        self.search_master = createMasterCollection(parent=self, Footer=self.footer,  master_progress_bar= self.master_progress_bar)

        self.tableview_compare = self.ui.tableView

        # Connect the menu action to the database function
        #runs searchCollectins in the methos below to initiate search of a selected location
        self.ui.actionChoose_Local_Drive.triggered.connect(self.searchCollections)


        # Master collection search menu option
        self.ui.actionselect_Master_Location.triggered.connect(self.searchMasterCollections)


        #Searching option on main menu when clicked displays collections in the footer
        self.ui.actionSearching.triggered.connect(self.display_collections)

        # stacked widget page to compare sets
        self.ui.actionCompare_Sets.triggered.connect(self.compareSets)

        #menu options quits the program
        self.ui.actionQuit.triggered.connect(self.program_exit)
       
        #not yet implemented other than as a menu option
        self.ui.actionFile_Extension_List.triggered.connect(self.viewExtensions)

        


        #initialises 2 combo boxes from the gui in stacked widget pie analysis page 1
        # collection filter como boxes
        self.dev_combo=self.ui.dev_combo
        self.cat_combo=self.ui.cat_combo


        #iniyialize 3 combo boxes from the gui in stacked widget compare collections page 2
        self.combo_compareA=self.ui.combo_compareA
        self.combo_compareB=self.ui.combo_compareB
        self.combo_compareType=self.ui.combo_compareType
        self.comboBox_table1=self.ui.comboBox_table1
        self.comboBox_table2=self.ui.comboBox_table2

        self.populate_comparison_combos()

        self.compare_btn=self.ui.compare_btn
        self.compare_btn.clicked.connect(self.run_comparison)

        #Radio Buttons for choosing collection Type
        self.masterRadio=self.ui.masterRadio
        self.collRadio=self.ui.collRadio

        # Connect the radio buttons to the populate_combo_boxes method
        self.masterRadio.toggled.connect(self.populate_combo_boxes)
        self.collRadio.toggled.connect(self.populate_combo_boxes)


        #Refresh Chart Button
        self.chartButton = self.ui.chartButton
        self.chartButton.clicked.connect(self.update_pie_chart)  # Connect the button click to the method

       

        self.collRadio.setChecked(True)
        



        # Connect combo box signals to the update method
        # when the selected value changes in the combo box a new chart is drawn
        #self.dev_combo.currentIndexChanged.connect(self.update_pie_chart)
        #self.cat_combo.currentIndexChanged.connect(self.update_pie_chart)

        # Call the method to populate the combo boxes
        #self.populate_combo_boxes() 

        
        # Connect the menu action to the viewCollections function
        # Optionally, set minimum sizes if needed
        #self.ui.pi_collections.setMinimumSize(100, 100)
        #self.ui.frame_2.setMinimumSize(100, 100)
        self.ui.actionCollections_2.triggered.connect(self.viewCollections)

        self.canvas_frame=self.ui.canvas_frame
        self.coll_frame_table=self.ui.coll_frame_table


    def run_comparison(self):
        # This method will be called when the button is clicked
        print("Compare button clicked!")
        # Add your logic here  
        # Get the selected values from the combo boxes
        selected_compareA = self.combo_compareA.currentText()
        selected_compareB = self.combo_compareB.currentText()
        selected_compareType = self.combo_compareType.currentText()  

        # Print the selected values for debugging purposes
        print(f"Selected Collection A: {selected_compareA}")
        print(f"Selected Collection B: {selected_compareB}")
        print(f"Selected Comparison Type: {selected_compareType}")

        ''' the run method in the compare collections class deals with the differen
        combination of possibilities from the combo boxes - there will be a lot'''
        comparison = Compare_Collections(selected_compareA, selected_compareB, selected_compareType, self.tableview_compare,self.comboBox_table1, self.comboBox_table2)
        comparison.run()

    

    
    
    #bar chart combo boxes
    def populate_combo_boxes(self):

         # Determine which radio button is selected
        if self.masterRadio.isChecked():
            selected_radio = "master"
        elif self.collRadio.isChecked():
            selected_radio = "collection"
        else:
            selected_radio = None  # Default or error handling

        # Use the selected radio button value as needed
        print(f"Selected radio button: {selected_radio}")



        # Temporarily disconnect signals to prevent premature updates
        #try:
            #self.dev_combo.currentIndexChanged.disconnect(self.update_pie_chart)
        #except TypeError:
           # pass  # Signal was not connected

        #try:
           # self.cat_combo.currentIndexChanged.disconnect(self.update_pie_chart)
        #except TypeError:
           # pass  # Signal was not connected




        # Get distinct devices and categories

        devices = get_distinct_values_with_all('device',selected_radio)
        categories = get_distinct_values_with_all('category', selected_radio)
        
        # Populate dev_combo
        self.dev_combo.clear()
        self.dev_combo.addItems(devices)
        
        # Populate cat_combo
        self.cat_combo.clear()
        self.cat_combo.addItems(categories)

        # Reconnect signals after populating
        #self.dev_combo.currentIndexChanged.connect(self.update_pie_chart)
        #self.cat_combo.currentIndexChanged.connect(self.update_pie_chart)


    def populate_comparison_combos(self):
        
        collections = get_unique_locations()
        
        
        # Populate dev_combo
        self.combo_compareA.clear()
        self.combo_compareB.clear()
        self.combo_compareA.addItems(collections)
        self.combo_compareB.addItems(collections)
        items = ['Items in B but Not in A','Items in A but Not in B']
        self.combo_compareType.addItems(items)
        tables = ['mediafiledetail','masterfiledetail']
        self.comboBox_table1.addItems(tables)
        self.comboBox_table2.addItems(tables)
        
       
        

    def display_collections(self):
        print("ready to display collections")
        '''shows a summary of all collections on footer panel'''

        # Clear the footer content
        print("Clearing the footer content.")
        self.footer.clear()

        # Fetch the collection summary from the database
        print("Fetching collection summary from the database.")
        results = fetch_collection_summary()

        # Check if results were fetched successfully
        if results:
            print(f"Fetched {len(results)} records from the database.")
        else:
            print("No records fetched from the database or connection failed.")

        # Format the results as a string
        print("Formatting the results for display.")
        results_text = self.format_results(results)

        # Display the results in the Footer QTextEdit
        print("Displaying the formatted results in the footer.")
        self.footer.setPlainText(results_text)

    def format_results(self, results):
        """Formats the results into a string for display."""
        formatted_text = ""
        for row in results:
            # Assuming each row is a tuple, join the elements with tabs or any other separator
            formatted_text += "\t".join(map(str, row)) + "\n"
        return formatted_text

    #invokes the run() method in the searchLocation file
    #this handles the code that creates the collections found at a location
    def searchCollections(self):
        print("inside searchCollections")
        self.display_collections()
        #this keeps coding on this page to a minimum
        #by calling searchLocation function
        # Delegate the database connection test to SearchLocation
        #Main search functions to identify and create collections
        result = None
        # in the code below we instantiared search_instance from the imported DearchLocation class.
        #run() is a method in that class so we can refer to it as search_instance.run()
        #The run method manages the whole media collection/media creation process
        result = self.search_instance.run()
        #sys.exit()
       
    #invokes the run() method in the searchMasterLocation file
    #this handles the code that creates the collections found at a location
    def searchMasterCollections(self):
        print("inside searchMasterCollections")
        self.display_collections()
        #this keeps coding on this page to a minimum
        #by calling searchLocation function
        # Delegate the database connection test to SearchLocation
        #Main search functions to identify and create collections
        result = None
        # in the code below we instantiared search_instance from the imported DearchLocation class.
        #run() is a method in that class so we can refer to it as search_instance.run()
        #The run method manages the whole media collection/media creation process
        result = self.search_master.run()
        #sys.exit()   

    
    def program_exit(self):
        print("exit")
        #this keeps coding on this page to a minimum
        #by calling searchLocation function
        # Delegate the database connection test to SearchLocation
        #Main search functions to identify and create collections
        
        sys.exit()
    
    
    def viewExtensions(self):    
        None

    def viewCollections(self):

        
        
        print("now inside viewCollections method")
        # Fetch data from the database
        data = summary_coll_list()  # This should return a list of tuples (location, file_count, total_file_size)

        # Ensure the canvas_frame has a layout
        if not self.ui.canvas_frame.layout():
           self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())


         # Create and show the pie chart widget with new data
        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)

        # Calculate the available width and set the maximum width for the canvas
        #available_width = self.ui.canvas_frame.width()
        #print(f"available width A",available_width)
        #self.pie_chart_widget.canvas.setMaximumWidth(available_width+400)

        # Remove the existing pie chart widget if it exists
        if hasattr(self, 'pie_chart_widget'):
            self.ui.canvas_frame.layout().removeWidget(self.pie_chart_widget)
            self.pie_chart_widget.deleteLater()

        #moved to top of method  Create and show the pie chart widget with new data
        #self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)

        # Calculate the available width and set the maximum width for the canvas
        #available_width = self.ui.canvas_frame.width()
        #print(f"available width B", available_width)
        #self.pie_chart_widget.canvas.setMaximumWidth(available_width)

        # Add the pie_chart_widget to the layout of canvas_frame
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)

        # Set the current widget in the stacked widget if needed
        self.ui.stackedWidget.setCurrentWidget(self.ui.page)

        #this function justs tests for a database connection in case the server is off
    def run_connection_test(self):
        """Runs the database connection test and handles the result."""
        print("running test")
        state = test_mysql_connection()
    
        if state:   
            message = "MySql is Connected........."
        else:
            message= "No Mysql Connection........."
           
        self.footer.append(message)

    def update_pie_chart(self):
        # Get the selected values from the combo boxes
        selected_device = self.dev_combo.currentText()
        selected_category = self.cat_combo.currentText()



         # Determine which radio button is selected
        if self.masterRadio.isChecked():
            selected_radio = "master"
        elif self.collRadio.isChecked():
            selected_radio = "collection"
        else:
            selected_radio = None  # Default or error handling

        # Use the selected radio button value as needed
        print(f"Selected radio button: {selected_radio}")




        # Fetch data from the database with the selected filters
        data = get_filtered_data(selected_device, selected_category,selected_radio)

         # Remove the existing pie chart widget if it exists
        #if hasattr(self, 'pie_chart_widget'):
            #self.ui.canvas_frame.layout().removeWidget(self.pie_chart_widget)
            #self.pie_chart_widget.setParent(None)  # Detach from parent
            #self.pie_chart_widget.deleteLater()
            #self.pie_chart_widget = None

        # Create and show the pie chart widget with new data
        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)

         # Reconnect the pick_event listener after creating the new pie chart
        self.pie_chart_widget.canvas.mpl_connect('pick_event', self.pie_chart_widget.on_bar_click)


        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)

        # Refresh the pie chart with the new data
        #self.refresh_pie_chart(data)
        # Ensure the pie chart has the correct width and redraw
        available_width = self.ui.canvas_frame.width()
        self.pie_chart_widget.canvas.setMaximumWidth(available_width)

        # Redraw the canvas
        self.pie_chart_widget.canvas.draw()


    def refresh_pie_chart(self, data):
        """Refreshes the pie chart with new data."""
        # Ensure the canvas_frame has a layout
        if not self.ui.canvas_frame.layout():
            self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())

        # Remove the existing pie chart widget if it exists
        if hasattr(self, 'pie_chart_widget'):
            self.ui.canvas_frame.layout().removeWidget(self.pie_chart_widget)
            self.pie_chart_widget.deleteLater()

        # Create and show the pie chart widget with new data
        self.pie_chart_widget = pie_collection(data,self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)

        # Set the maximum width for the canvas
        available_width = self.ui.canvas_frame.width()
        self.pie_chart_widget.canvas.setMaximumWidth(available_width)

        # Add the pie_chart_widget to the layout of canvas_frame
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)


    def compareSets(self):
        new_page_index = 1  # Replace with the actual index of your new page
        self.ui.stackedWidget.setCurrentIndex(new_page_index)
    