'''
 based on version 1.0 and amended





 This file has been created to make use of the .py file generated by the following command run from the command line
 pyuic5 -o newfile.py MainWindow.ui
pyuic5 -o MediaManager.py MediaManager.ui

the idea is that as you make changes to the UI and rerun pyuic5 the contruction of the windows
 is separate from the UI code
 getMainWindow inherits the MainWindow properties and in this file we can place our code for listeners, action etc


 MainWindow.ui is created by designer and is an xml file
 the pyuic command generates a .py equivalent file but you must not change any aspect of this file as when# you change the gui it rewrites the file and you lose the changes
 The correct approach is to create a file like this one that subclasses the Ui_MainWindow,
 which is the class created in
 MainWindow.py, you must take care to note the class of object that the gui file is based on.
 MainWindow is based on QTWidgets.QMainWindow but it could easily be based on just QTWidgets as you will see from
 the database example. The main window has the main menu and will have lots of signals and slots associated with it

 In this example we use the database screen to show after clicking a button
 To do this we need to import and other files and classes that the button click references
 getMasterdb is a file created to access getDbWidow class, this being the class that manages the gui created by
 py designer

 pyuic5 -o CreateMasterdatabase.py CreateMasterDatabase.ui
 pyuic5 -o MainWindow.py MainWindow.ui
 pyuic5 -o FFMpeg.py ffmpeg.ui
 pyuic5 -o moveNewFiles.py moveNewFiles.ui
 pyuic5 -o GroupAnalysis.py GroupAnalysis.ui
 pyuic5 -o MediaManager.py MediaManager.ui



 Note ------this pyuic5 is not really necessary. Its good practice on larger projects to do this as it keeps the ui code separate from the logic code
 for smaller projects its not necessary, as shown in Music.py you can manually create the .py file subclassling the window and then just add the logic
 its quicker as you dont need to keep running pyuic5 each time you modify the ui

'''


''' The purpose of the following changes is to resolve the problem of the SearchMasterLocation Class failing to 
communicate with the Main GUI. The new approoch is as follows

getMainWindow instantiates createMasterCollection. This creates a messagebox that gets 3 pieces of information
start_path of search
Type of collection eg Music
Tyoe of master eg clone

The current system instantiates SearchMasterLocation from createMasterCollection and that creates a worker thread which needs to send a signal back to getMainWindow

This doesnt work so the alternative is to pass the three pieces of data back to getMainWindow which then instantiate SearchMasterLocation passing 
the count back to the LCD widget in the same way that SearchLocation does it

hopefully that will solve the problem

step 1 clear out all references to the old way of working
 self.data_from_createMasterCollection = None  object holding results fro messagebox in createmastercollection

 created a method to use the above returned data, passed in from the click on the messagebox in createmastercollection
  def data_from_createMasterColl(self, data): 
            method self.data_from_createMasterCollectionb = data # Store the received data 
            print(f"Received data: {data}") 
            self.c_instance = C(self.data_from_b) self.c_instance.do_something() # I need a statement to run searchMasterCollection and the worker2
            #also need to set up arrangement for incrament file counter just like searchCollection

            this triggers creation of the messagebox
            self.ui.actionselect_Master_Location.triggered.connect(self.searchMasterCollections)

            #this method runs the messagebox .run method
             def searchMasterCollections(self):
                logging.info("Running searchMasterCollections")
                self.display_collections().......displays collections on the footer
                self.search_master.run()
                                this passes in the following  
                                self.search_master = createMasterCollection(
                                                parent=self, Footer=self.footer, master_progress_bar=self.master_progress_bar)


                                                

'''




import sys
import os
import logging
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QVBoxLayout, QTextEdit, QFileDialog, QProgressBar
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtCore import Qt, QTimer  # Import Qt namespace
from dbMySql import db_utils
from PyQt5.QtGui import QPixmap
from dbMySql.db_utils import (
    test_mysql_connection,
    summary_coll_list,
    get_distinct_values_with_all,
    get_filtered_data,
    get_unique_locations,
    fetch_collection_summary,
    get_location_by_collection
    
)
import os
import subprocess
from MediaManager import Ui_MainWindow
from srcMedia.searchLocation import SearchLocation
from srcMedia.createMasterCollection import createMasterCollection
from srcMedia.SearchMasterLocation import SearchMasterLocation
from srcMedia.pie_collection import pie_collection
from srcMedia.compare_collections import Compare_Collections
from srcMedia.lcd_updater import LCDUpdater
from srcMedia.searchLocation import Worker
from srcMedia.SearchMasterLocation import Worker2
from datetime import datetime
from srcMedia.UtilClass import UtilClass
from srcMedia.EditPanel import EditPanelManager
from srcMedia.SearchHandler import SearchHandler
from srcMovie import ffmpegFunc
from srcMovie.ffmpegFunc import checkError, FFmpegWorker, viewError, repairError
from srcMovie.ffmpegFunc import RepairWorker
from srcMovie.ffmpegFunc import convFile
from tkinter import filedialog
import traceback
from srcMovie import convertMedia2
from srcMovie.convertMedia2 import FFmpegControlPanel
from PyQt5.QtWidgets import QWidget



class getWindow(QMainWindow):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.showMaximized()


        #help  setup
        self.helpPanel = self.ui.helpPanel
        #self.ui.actionSystem_Overview.triggered.connect(lamdba: self.help_system_overview())
        #add more help pages and methods here

        #FFMPEG
        self.progressBarFF = self.ui.progressBarFF
        self.pulse_timer = QTimer(self)
        self.pulse_timer.timeout.connect(self.pulse_progress_bar)

        self.ffmpeg = self.ui.FFMPEG
        self.error_textpane = self.ui.error_textpane

        # used withh ffmpeg error report
        self.worker = None  # Initialize a reference to the worker thread used later
        #self.progressBarFF_timer = QTimer(self)
        #self.progressBarFF_timer.timeout.connect(self.update_progress_bar)
        
        

        #ToDo List setup
        self.ToDoList = self.ui.LeftColumn
        self.ToDoList.textChanged.connect(self.saveToDoList)

        #deal with image display
        self.imageLabel=self.ui.homeImageContainer
        self.imageLabel.setAlignment(Qt.AlignCenter)  # Center the image

        image_path = "D:\\PythonMusic\\pythonProject6\\music-new\\images\\splashFinal1.png"
        if not os.path.exists(image_path):
            print("Image file does not exist at the specified path.")

        # Load the image using QPixmap
        pixmap = QPixmap("D:\\PythonMusic\\pythonProject6\\music-new\\images\\splashFinal1.jpg")  
        self.imageLabel.setPixmap(pixmap)

        self.imageLabel.setScaledContents(True)

        #set up Right Column for tips content
        self.tips_panel = self.ui.RightColumn
        self.tips_panel.setReadOnly(True)  # Make it read-only
        #For EUtilities help page
        self.utilNotice = self.ui.utilNotice
        self.utilNotice.setReadOnly(True)  # Make it read-only



        

        self.footer = self.ui.Footer
        self.media_progress_bar = self.ui.media_thread_progress
        self.master_progress_bar = self.ui.master_thread_progress

        #search panel display
        self.searchTableWidget = self.ui.searchTableWidget
        self.searchEdit = self.ui.searchEdit
        self.search_button = self.ui.searchButton

     

        #control panel display
        self.cpu_lcd = self.ui.cpu_lcd
        self.ram_lcd = self.ui.ram_lcd
        self.lan_lcd = self.ui.lan_lcd
        self.filecount_lcd = self.ui.filecount_lcd

        # Initialize the LCDUpdater
        self.lcd_updater = LCDUpdater(self.cpu_lcd, self.ram_lcd, self.lan_lcd)


        #initialozation
        self.search_instance = SearchLocation(self, Footer=self.footer, media_progress_bar=self.media_progress_bar)

        #### action - parent = self is a reference to getWindow - createMasterCollection needs to create a separate reference to in so that it can be passed on and getWindow methods used to access it
        ### needed to remove parent reference
        self.search_master = createMasterCollection(
            self, Footer=self.footer, master_progress_bar=self.master_progress_bar)
        
        self.data_from_createMasterCollection = None

        #data to be returned from SearchMasterCollection
        self.master_media_type = None
        self.master_master_type = None
        self.master_selected_path = None

        #Elapsed Time display
        self.time_started = self.ui.Started
        self.time_ended = self.ui.Ended

        self.setup_connections()
        self.populate_comparison_combos()
        self.run_connection_test()
        #self.setStartTime()
        #self.setEndTime()

        #load tips page default
        # Assuming this is part of your class where self.tips_panel is already initialized
        self.display_html_content("splash.html")
        self.display_html_util("utilNotice.html")

        self.loadToDoList()
        self.fileDialogOpen = False  # Flag to check if the file dialog is open
        

    def setup_connections(self):
        self.ui.actionChoose_Local_Drive.triggered.connect(self.searchCollections)
        self.ui.actionselect_Master_Location.triggered.connect(self.searchMasterCollections)
        self.ui.actionSearching.triggered.connect(self.display_collections)
        self.ui.actionCompare_Sets.triggered.connect(self.compareSets)
        self.ui.actionQuit.triggered.connect(self.program_exit)
        self.ui.actionFile_Extension_List.triggered.connect(self.viewExtensions)
        self.ui.actionCollections_2.triggered.connect(self.viewCollections)
        self.ui.actionEdit_Types.triggered.connect(self.viewEditPanel)
        self.ui.actionSearch.triggered.connect(self.searchText)

        # Setup connections for utility actions
        self.ui.actionRemove_Sets.triggered.connect(lambda: self.util_actions("Remove"))
        self.ui.actionDelete_Sets.triggered.connect(lambda: self.util_actions("Delete"))
        self.ui.actionMove_Sets.triggered.connect(lambda: self.util_actions("Move"))
        self.ui.actionTransfer_Sets.triggered.connect(lambda: self.util_actions("Transfer"))


        #connection for FFMpeg
        #error test
        
        self.testFFFileButton = self.ui.testFFFileButton
        self.ui.testFFFileButton.clicked.connect(self.on_testFFFileButton_clicked) #runs the action associated with the click
        self.ui.actionTesting.triggered.connect(self.loadFFMPEG)    #sets current widget and html
        
        # Before connecting the signal
        #print(f"Connections before: {self.viewError.receivers(self.viewError.clicked)}")
        #self.viewError.clicked.disconnect()
        #self.viewError.clicked.connect(self.on_viewFFFileButton_clicked)
        #print(f"Connections after: {self.viewError.receivers(self.viewError.clicked)}")
        
        #view error and file details
        #self.viewFFFileButton = self.ui.viewFFFileButton
        #self.viewError = self.ui.viewFFFileButton
        self.ui.viewFFFileButton.clicked.connect(self.viewFFFileButton_clicked)
        
        self.ui.repairFFButton.clicked.connect(self.repairFFFileButton_clicked)
        self.ui.playFFButton.clicked.connect(self.playMovie)
        #self.ui.convertFFButton.clicked.connect(self.convertMovie)

        self.ui.convertFFButton.clicked.connect(self.start_transcoding_process)



        #QTable widget in gui for utils display
        self.coll_table = self.ui.coll_table

        self.ui.masterRadio.toggled.connect(self.populate_combo_boxes)
        self.ui.collRadio.toggled.connect(self.populate_combo_boxes)

        self.ui.chartButton.clicked.connect(self.update_pie_chart)
        self.ui.compare_btn.clicked.connect(self.run_comparison)
        
        self.ui.collRadio.setChecked(True)

        self.searchHandler = None

        self.searchText()

        # Set the splash page as the default page
        self.ui.stackedWidget.setCurrentWidget(self.ui.Home)


    
    
    
    def loadToDoList(self):
        try:
            with open('ToDo.txt', 'r') as file:
                self.ToDoList.setPlainText(file.read())
        except FileNotFoundError:
            pass

    def saveToDoList(self):
         with open('ToDo.txt', 'w') as file:
            file.write(self.ToDoList.toPlainText())

    ##RH page help pages
    def display_html_content(self, filename):
        # Construct the relative path to the HTML file
        relative_path = os.path.join("srcMedia", "HelpPages", filename)

        # Read the content of the HTML file
        try:
            with open(relative_path, 'r', encoding='utf-8') as file:
                content = file.read()
                # Set the content to the QTextEdit
                self.tips_panel.setHtml(content)  # Use setHtml for rich text
                
        except FileNotFoundError:
            self.tips_panel.setPlainText("HTML file not found.")
        except Exception as e:
            self.tips_panel.setPlainText(f"An error occurred: {e}")

    #utilities help page
    def display_html_util(self, filename):
       
        # Construct the relative path to the HTML file
        relative_path = os.path.join("srcMedia", "HelpPages", filename)

        # Read the content of the HTML file
        try:
            with open(relative_path, 'r', encoding='utf-8') as file:
                content = file.read()
                # Set the content to the QTextEdit
                self.utilNotice.setHtml(content)  # Use setHtml for rich text
                self.utilNotice.setHtml(content)
        except FileNotFoundError:
            self.tips_panel.setPlainText("HTML file not found.")
        except Exception as e:
            self.tips_panel.setPlainText(f"An error occurred: {e}")

    def searchText(self):
        self.ui.stackedWidget.setCurrentWidget(self.ui.splash)
        self.display_html_content("Search.html")
        self.search_handler = SearchHandler(self.ui.searchTableWidget,  self.ui.searchEdit, self.ui.searchButton)

    def loadFFMPEG(self):
        print("ff menu test clicked")
        self.display_html_content("FFMPEG.html")
        self.ui.stackedWidget.setCurrentWidget(self.ui.FFMPEG)

    def repairFFFileButton_clicked(self):
        """Opens a file dialog to select a video file and starts the repair process."""
        print("Repairing video file method in getMainWindow")
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly  # Open dialog in read-only mode
        file_path, _ = QFileDialog.getOpenFileName(
            None,  # No parent widget
            "Select a Video File",  # Dialog title
            "W:\\Collection",  # Initial directory
            "All Files (*)",  # File filter to allow any file type
            options=options
        )
        
        if file_path:  # Check if a file was selected
            escaped_file_path = file_path.replace("\\", "\\\\")
            print("Escaped file path:", escaped_file_path)

            # Create an instance of RepairWorker
            self.worker = RepairWorker(escaped_file_path, self.footer, self.progressBarFF)

            # Connect signals to update the UI
            self.worker.update_footer.connect(self.footer.append)
            self.worker.start_progress.connect(self.start_pulsing)
            self.worker.stop_progress.connect(self.stop_pulsing)

            # Start the worker thread
            self.worker.start()

            message = f"Success: File '{file_path}' repair process started."
            self.footer.append(message)
        else:
            message = "No file selected."
            self.footer.append(message)
    


    def playMovie(self):
        """
        Opens a file dialog to select a video file and plays it using CyberLink PowerDVD.
        """
        print("Inside playMovie getMainWindow")
        
        # Open a file dialog to select a video file
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_path, _ = QFileDialog.getOpenFileName(self, "Select a Video File", "", "Video Files (*.mp4 *.avi *.mkv);;All Files (*)", options=options)
        
        if file_path:
            try:
                # Ensure the file exists
                if not os.path.isfile(file_path):
                    raise FileNotFoundError(f"The file {file_path} does not exist.")
                    
                # Path to the PowerDVD executable
                powerdvd_path = r"C:\Program Files\CyberLink\PowerDVD20\PowerDVD.exe"
                    
                # Command to open the video file with PowerDVD
                cmd = [powerdvd_path, file_path]
                    
                # Execute the command
                subprocess.run(cmd, check=True)
                    
                # Provide feedback to the user
                #QMessageBox.information(self, "Success", f"Playing video: {file_path}")
            
            except FileNotFoundError as fnf_error:
                    QMessageBox.critical(self, "File Not Found", str(fnf_error))
            except subprocess.CalledProcessError as cpe_error:
                    QMessageBox.critical(self, "Playback Error", f"An error occurred while trying to play the video: {cpe_error}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")
        else:
            QMessageBox.warning(self, "No File Selected", "Please select a video file to play.")




    def convertMovie(self):
        """
        Opens a file dialog to select a video file from 'W:\\Collection' and converts it using the convFile function.
        """
        print("Inside convertMovie getMainWindow")
        
        # Open a file dialog to select a video file
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_path, _ = QFileDialog.getOpenFileName(
            self, 
            "Select a Video File", 
            "W:\\Collection",  # Initial directory
            "Video Files (*.mp4 *.avi *.mkv);;All Files (*)", 
            options=options
        )
        
        if file_path:
            print("File selected")
            try:
                print("Try block")
                # Ensure the file exists
                if not os.path.isfile(file_path):
                    raise FileNotFoundError(f"The file {file_path} does not exist.")
                
                print("Getting conversion result")
                result = convFile(file_path)  
                print("Past conversion result")  

                # Get the current date and time
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                
                # Provide feedback to the user
                message = f"Success: File '{file_path}' conversion started at {current_time}"
                self.footer.append(message)
            
            except FileNotFoundError as fnf_error:
                QMessageBox.critical(self, "File Not Found", str(fnf_error))
            except subprocess.CalledProcessError as cpe_error:
                QMessageBox.critical(self, "Conversion Error", f"An error occurred during conversion: {cpe_error}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")
        else:
            QMessageBox.warning(self, "No File Selected", "Please select a video file to convert.")

    def viewFFFileButton_clicked(self):
        """Opens a file dialog to select a .txt file from the 'W:\\Collection' folder."""
        print("viewing error file method hetMainWindow")
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly  # Open dialog in read-only mode
        file_path, _ = QFileDialog.getOpenFileName(
            None,  # No parent widget
            "Select a .txt File",  # Dialog title
            "W:\\Collection",  # Initial directory
            "Text Files (*.txt)",  # File filter
            options=options
        )
            
        if file_path:  # Check if a file was selected
            escaped_file_path = file_path.replace("\\", "\\\\")
            print("Escaped file path:", escaped_file_path)

            viewError(escaped_file_path, self.error_textpane)

            message = f"Success: File '{file_path}' processed successfully."
            self.footer.append(message)
        else:
            message = "No file selected."
            self.footer.append(message)

    def on_testFFFileButton_clicked(self):
        print("FFmpeg button click   running")
        
        # Check if the worker is already running
        #The function checks if a worker thread (self.worker) is already running. If it is not None, it means a worker is currently active,
        #  and the function returns early to prevent starting another task. This ensures that only one FFmpeg process runs at a time.
        if self.worker is not None:
            print("A worker is already running. Ignoring button click.")
            return
        
        # Open a file dialog to select a file for FFmpeg testing
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_path, _ = QFileDialog.getOpenFileName(self, "Select a File", "", "All Files (*)", options=options)

        if file_path:
            try:
                # Start pulsing the progress bar
                self.start_pulsing()

                # Escape the file path for safe usage
                escaped_file_path = file_path.replace("\\", "\\\\")
                print("Escaped file path:", escaped_file_path)

                # Call checkError to get the worker
                #The checkError function is called with the escaped file path and a reference to self.error_textpane. This function returns
                #  a worker object (self.worker) that handles the FFmpeg process in a separate thread.
                self.worker = checkError(escaped_file_path, self.error_textpane)
                #self.worker = FFmpegWorker(escaped_file_path, self.error_textpane)
                self.worker.output_signal.connect(self.error_textpane.append)

                # Connect the worker's finished signal to stop pulsing when the task is done
                self.worker.finished_signal.connect(self.on_worker_finished)

                # Start the worker thread
                #The worker thread is started, initiating the FFmpeg process.
                self.worker.start()

                message = f"Success: File '{file_path}' processed successfully."
                self.footer.append(message)

            except Exception as e:
                message = f"Error: An error occurred: {e}"
                self.footer.append(message)

        else:
            message = "No File Selected"
            self.footer.append(message)

    def start_pulsing(self):
        # Set the progress bar to be indeterminate (will be pulsing)
        self.progressBarFF.setRange(0, 0)
        # Start the pulse timer
        self.pulse_timer.start(100)  # Pulse every 100 ms

    def stop_pulsing(self):
        # Stop the pulse timer
        self.pulse_timer.stop()
        # Reset the progress bar to a determinate state
        self.progressBarFF.setRange(0, 100)
        self.progressBarFF.setValue(0)

    def pulse_progress_bar(self):
        # This method is called by the timer to simulate pulsing
        current_value = self.progressBarFF.value()
        # Toggle between 0 and 100 to simulate pulsing effect
        new_value = 100 if current_value == 0 else 0
        self.progressBarFF.setValue(new_value)

    def on_worker_finished(self):
        """Slot to stop the progress bar when the worker is finished"""
        self.stop_pulsing()
        print("Worker finished, pulsing stopped.")
        self.worker = None  # Optionally clear the worker reference
        print("Worker reference cleared.")


    def setStartTime(self):
        self.time_started.setText("")
        self.time_ended.setText("")
        current_time = datetime.now().strftime("%H:%M:%S")
         # Set the current time as text in the label
        self.time_started.setText(current_time)
    
    def compareSets(self):
        self.display_html_content("compareCollections.html")
        self.ui.stackedWidget.setCurrentWidget(self.ui.Comparisons)

    def setEndTime(self):
        print("trying to set end time")
        self.time_ended.setText("")
        current_time = datetime.now().strftime("%H:%M:%S")
        self.time_ended.setText(current_time)

    ''' This method covers the 3 menu options for the utilities menu option for managing sets
    a different menu choice will pass a different value''' 
    def util_actions(self, action_type):

        print("entering util actions")

         # Switch to the 'Utils' page in the stacked widget
        self.ui.stackedWidget.setCurrentWidget(self.ui.Utils)
        
        '''
        # Handle the action based on the passed value
        if action_type == "Remove":
            print("Performing Remove action")
            # Add logic for Remove action here
        elif action_type == "Delete":
            print("Performing Delete action")
            # Add logic for Delete action here
        elif action_type == "Move":
            print("Performing Move action")
            # Add logic for Move action here '''
        
        print("==================================")
        print(f"Utils Page: {type(self.ui.Utils)}")
        print(f"Coll Table: {type(self.coll_table)}")
        print(f"Action Type: {action_type}")
        print(f"Footer: {type(self.footer)}")
        # Initialize the class that will work with the 'Utils' page
        self.tips_panel.clear()
        self.util_class_instance = UtilClass(self.ui.Utils, self.coll_table, action_type, self.footer)
        #self.collection_util = collection_util(self, coll_table=self.coll_table, action = action_type Footer=self.footer )

    def run_connection_test(self):
        try:
            state = test_mysql_connection()
            message = "MySql is Connected........." if state else "No Mysql Connection........."
            self.footer.append(message)
        except Exception as e:
            logging.error(f"Error testing MySQL connection: {e}")
            self.footer.append("Error testing MySQL connection.")

    def populate_combo_boxes(self):
        logging.info("Running populate_combo_boxes")
        selected_radio = "master" if self.ui.masterRadio.isChecked() else "collection"
        devices = get_distinct_values_with_all('device', selected_radio)
        categories = get_distinct_values_with_all('category', selected_radio)

        self.ui.dev_combo.clear()
        self.ui.dev_combo.addItems(devices)

        self.ui.cat_combo.clear()
        self.ui.cat_combo.addItems(categories)

    def populate_comparison_combos(self):
        collections = get_unique_locations()
        self.ui.combo_compareA.clear()
        self.ui.combo_compareB.clear()
        self.ui.combo_compareA.addItems(collections)
        self.ui.combo_compareB.addItems(collections)

        items = ['Items in B but Not in A', 'Items in A but Not in B']
        self.ui.combo_compareType.addItems(items)

        tables = ['mediafiledetail', 'masterfiledetail']
        self.ui.comboBox_table1.addItems(tables)
        self.ui.comboBox_table2.addItems(tables)

    def data_from_createMasterColl(self,media_type, master_type, selected_path): 
            #self.data_from_createMasterCollectionb = data # Store the received data 
            #print(f"Received data: {data}") 
            #self.c_instance = C(self.data_from_b) self.c_instance.do_something()
            print("bg")
            self.master_media_type = media_type
            self.master_master_type = master_type
            self.master_selected_path = selected_path
            logging.info(" have setup date from createMasterCollections")
            print("bg feedback variables assigned")
            self.create_master()

    def run_comparison(self):
        selected_compareA = self.ui.combo_compareA.currentText()
        selected_compareB = self.ui.combo_compareB.currentText()
        selected_compareType = self.ui.combo_compareType.currentText()
        ##combobox_table1 not needed
       
        comparison = Compare_Collections(
            selected_compareA, selected_compareB, selected_compareType,
            self.ui.tableView, self.ui.comboBox_table1, self.ui.comboBox_table2
        )
        comparison.run()

    def display_collections(self):
        logging.info("Running display_Collections")
        self.footer.clear()
        results = fetch_collection_summary()
        results_text = self.format_results(results)
        self.footer.setPlainText(results_text)

    def format_results(self, results):
        return "\n".join("\t".join(map(str, row)) for row in results)

    def searchCollections(self):
        logging.info("Running searchCollections")
        self.display_html_content("MediaCreate.html")
        self.display_collections()
        self.search_instance.run()

        # Connect the worker's signal to update the file count LCD
        self.search_instance.worker.record_counter_signal.connect(self.update_filecount_lcd)

    
    def searchMasterCollections(self):
        logging.info("Running searchMasterCollections")
        self.display_html_content("MasterCreate.html")
        self.display_collections()
        self.search_master.run()

    def update_filecount_lcd(self, count):
        #print(f"Updating file count LCD with count: {count}")
        self.filecount_lcd.display(count)

    def program_exit(self):
        sys.exit()

    def viewExtensions(self):
        pass

    def viewCollections(self):
        logging.info("Running viewCollections")
        data = summary_coll_list()
        self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())
        self.display_html_content("ReportCollections.html")
        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)
        self.ui.stackedWidget.setCurrentWidget(self.ui.page)



    def viewEditPanel(self):
         # Instantiate the EditPanel class and pass the EditPanel widget
        self.edit_panel_manager = EditPanelManager(self.ui.EditPanel, self.footer)
        self.display_html_content("Edit_Types.html")

        self.ui.stackedWidget.setCurrentWidget(self.ui.EditPanel)

    def update_pie_chart(self):
        logging.info("Running update_pie_chart, gets get_filtered_data, runs refresh_pie_chart")
        selected_device = self.ui.dev_combo.currentText()
        selected_category = self.ui.cat_combo.currentText()
        selected_radio = "master" if self.ui.masterRadio.isChecked() else "collection"
        data = get_filtered_data(selected_device, selected_category, selected_radio)
        self.refresh_pie_chart(data)

    def refresh_pie_chart(self, data):
        logging.info("Running refresh_pie_chart, runs pie_collection")
        if not self.ui.canvas_frame.layout():
            self.ui.canvas_frame.setLayout(QtWidgets.QVBoxLayout())

        if hasattr(self, 'pie_chart_widget'):
            self.ui.canvas_frame.layout().removeWidget(self.pie_chart_widget)
            self.pie_chart_widget.deleteLater()

        self.pie_chart_widget = pie_collection(data, self.ui.canvas_frame, self.ui.coll_frame_table, parent=self)
        self.ui.canvas_frame.layout().addWidget(self.pie_chart_widget)

    #def compareSets(self):
        #self.ui.stackedWidget.setCurrentWidget(self.ui.Comparisons)

    def create_master(self):
        # Ensure master_progress_bar is not None before passing it
        if self.master_progress_bar is None:
            print("103 self.master_progress_bar is NONE")
            #raise ValueError("master_progress_bar must be provided and cannot be None.")
        else:
             print("103 self.master_progress_bar is OK")

        #self.window.close()

        selected_media_type = self.master_media_type
        selected_collection_type = self.master_master_type
        selected_selected_path =  self.master_selected_path
        print(f'Selected Path: {getattr(self, "selected_path", "None")}')
        print(f'Selected Media Type: {selected_media_type}')
        print(f'Selected Collection Type: {selected_collection_type}')
        # Here you can add logic to handle the selections, such as storing them in a database
        print("inside create_master")


        print(f"Parent type: {type(self.parent)}")  # Debugging line
        print(f"Has update_filecount_lcd: {hasattr(self.parent, 'update_filecount_lcd')}")


        # Initialize SearchMasterLocation instance
        # modify to pass in selected media and master details
        #self.search_master_instance = SearchMasterLocation(parent=self, Footer=self.footer, media_type=selected_media_type, master_type=selected_collection_type, start_location=self.selected_path)
        print(f"Parent type before instantiation: {type(self.parent)}")
        
        self.search_master = SearchMasterLocation(
            parent = self,
            Footer=self.footer,
            master_progress_bar = self.master_progress_bar,
            media_type=selected_media_type,
            master_type=selected_collection_type,
            selected_path=selected_selected_path  # Use 'selected_path' instead of 'start_location'
        )
        
        
        
        result = None
        # in the code below we instantiared search_instance from the imported DearchLocation class.
        #run() is a method in that class so we can refer to it as search_instance.run()
        #The run method manages the whole media collection/media creation process
        result = self.search_master.run()
        print("count connect")
        #self.search_master.worker2.record_counter_signal.connect(self.update_filecount_lcd)

    def open_file_explorer(self, collection_name, collection_category, collection_type):
        """Opens the file explorer at the location associated with the given collection to enable the user to delete a collection."""
        # Retrieve the location from the database
      
        
        location = get_location_by_collection(collection_name, collection_category, collection_type)
        
        if location:
            # Check if the location exists
            if os.path.exists(location):
                try:
                    # Open the file explorer at the specified location
                    if os.name == 'nt':  # Windows
                        os.startfile(location)
                    elif os.name == 'posix':  # macOS or Linux
                        subprocess.run(['open', location] if sys.platform == 'darwin' else ['xdg-open', location])
                except Exception as e:
                    self.footer.append(f"Error opening file explorer: {e}")
            else:
                self.footer.append("The specified location does not exist.")
        else:
            self.footer.append("Location not found for the specified collection.")
    
  
    
    def start_transcoding_process(self):
        print("....................7")
        """Method to start the transcoding process in a separate thread"""
        # Example: Collect settings from UI
        format_selected = "mp4"  # Replace with actual values from your UI
        codec_selected = "h265"
        crf_selected = "20"
        preset_selected = "slow"
        audio_selected = "auto"
        fps_optimization = True
        hwaccel_selected = "auto"
        print("....................8")

        # Create an instance of FFmpegWorker and pass selected options
        #self.ffmpeg_worker = TranscodeWorker(format_selected, codec_selected, crf_selected, preset_selected, audio_selected, fps_optimization, hwaccel_selected)
        self.ffmpeg_worker=FFmpegControlPanel(QWidget, self.progressBarFF)
        print("....................9")
        self.ffmpeg_worker.show()
        print("....................10")

        # Connect worker signals to UI updates
        #self.ffmpeg_worker.started.connect(self.start_pulsing)
        #self.ffmpeg_worker.finished.connect(self.stop_pulsing)
        #self.ffmpeg_worker.message.connect(self.update_footer)

        # Start the worker thread
       #self.ffmpeg_worker.start()
    